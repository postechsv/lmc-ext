--- The Maude Logical Bounded Model Checker Interface
--- Author: Kyungmin Bae <kbae4@illinois.edu>
--- Contributor: Kim Kyunwoo <kkw423@postech.ac.kr>

load model-checker

****************************************
***          Basic Interface         ***
****************************************

fmod RULE-NAME is
  extending QID .

  sort RuleName .
  subsort Qid < RuleName .
  ops unlabeled deadlock : -> RuleName .
endfm

fmod COMPLETENESS is 
    pr META-LEVEL .    
    pr SATISFACTION .

    sorts Completeness CompletenessSet .
    subsort Completeness < CompletenessSet .

    op incomplete : Bool -> Completeness [ctor] . --- Denotes true/false-COMPLETENESS of its corresponding proposition
    op complete : Bool -> Completeness [ctor] .
    op undefined : -> CompletenessSet [ctor] .

    op _,_ : CompletenessSet CompletenessSet -> CompletenessSet [assoc comm ctor id: undefined] .
    eq C:Completeness, C:Completeness = C:Completeness .

--- Pre-condition: CS is a CompletenessSet and B is a boolean value.
--- Post-condition: Returns a CompletenessSet containing the Completeness value in CS that matches the boolean B, or undefined if no match is found.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op find : CompletenessSet Bool -> CompletenessSet .
    eq find((complete(B:Bool), CS:CompletenessSet), B:Bool) = complete(B:Bool) .
    eq find((incomplete(B:Bool), CS:CompletenessSet), B:Bool) = incomplete(B:Bool) .
    eq find(CS:CompletenessSet, B:Bool) = undefined [owise] .

--- Pre-condition: CS and CS' are CompletenessSet values.
--- Post-condition: Returns a CompletenessSet containing the combined elements of CS and CS', resolving conflicts where a complete and incomplete entry for the same boolean exist (resulting in incomplete).
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op update : CompletenessSet CompletenessSet -> CompletenessSet [assoc] .
    eq update(CS:CompletenessSet, undefined) = CS:CompletenessSet .
    eq update(undefined, CS:CompletenessSet) = CS:CompletenessSet .
    eq update((complete(B:Bool), CS:CompletenessSet), (incomplete(B:Bool), CS':CompletenessSet)) = (incomplete(B:Bool), update(CS:CompletenessSet, CS':CompletenessSet)) .
    eq update((C:Completeness, CS:CompletenessSet), CS':CompletenessSet) = update(CS:CompletenessSet, CS':CompletenessSet) [owise] .
endfm

fmod STATE-SYNTAX is
    pr COMPLETENESS .

    sorts InitState ExState .
    subsorts InitState ExState < State .

    --- Initialization-only interface for specifying constraint incompleteness
    --- without embedding it in the InitState/ExState representation.
    sort InitStateSpec .
    op <<<_|_|_>>> : State Bool CompletenessSet -> InitStateSpec [ctor] .

    sorts PropMapping PropMap .
    subsort PropMapping < PropMap .

    op _*>_ : Prop Bool -> PropMapping [ctor] .
    op emptyPropMap : -> PropMap [ctor] .
    op __ : PropMapping PropMapping -> PropMapping [assoc ctor comm id: emptyPropMap] .

    --- if-and-only-if operator for boolean values
    --- We use this instead of Maude's standard == operator to delay reduction when non-ground terms are included in either side of the equation
    op _<=>_ : Bool Bool -> Bool .
    eq true <=> true = true .
    eq false <=> false = true .
    eq true <=> false = false .
    eq false <=> true = false .
    
    op _~_ : Universal Universal -> Bool [prec 51 poly (1 2)] .

    var PM : PropMap .
    vars P P' : Prop .
    var B : Bool .

--- Pre-condition: None
--- Post-condition: Determines if the values of given proposition map consist only of either true or false (that is, it doesn't include a boolean variable).
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op isComplete : PropMap -> Bool .
    eq isComplete(emptyPropMap) = true .
    eq isComplete(P *> true) = true .
    eq isComplete(P *> false) = true .
    eq isComplete((P *> true) (P' *> B) PM) = isComplete((P' *> B) PM) .
    eq isComplete((P *> false) (P' *> B) PM) = isComplete((P' *> B) PM) .
    eq isComplete(PM) = false [owise] .

    op <<<_|_>>> : State Bool -> InitState [ctor] .
    op {{{_|_|_}}} : State PropMap Bool -> ExState [ctor] .

    var ST : State .
    var CT : Bool .

    eq <<< ST | CT >>> |= P = ST |= P .

    eq {{{ ST | (P *> B) PM | CT }}} |= P = B .
    eq {{{ ST | PM | CT }}} |= P = false [owise] .

    sorts ExRuleElements ExInitRuleElements .
    op exRule : State PropMap Bool State PropMap Bool -> ExRuleElements [ctor] .
    op exInitRule : State Bool PropMap Bool -> ExInitRuleElements [ctor] .
endfm

fmod SYMBOLIC-CHECKER is
  pr RULE-NAME .
  pr SATISFACTION .
  pr STATE-SYNTAX .
  including LTL .

  subsort Prop < Formula .

*** generic substitution for counter example
  sorts CEAssignment CESubstitution .
  subsort CEAssignment < CESubstitution .
  op _<-_ : Qid Universal -> CEAssignment [ctor poly (2) prec 63] .
  op none : -> CESubstitution .
  op _;_ : CESubstitution CESubstitution -> CESubstitution [ctor assoc comm id: none prec 65] .
  eq CA:CEAssignment ; CA:CEAssignment = CA:CEAssignment .

*** transitions and results
  sorts Transition TransitionList ModelCheckResult .
  subsort Transition < TransitionList .
  subsort Bool < ModelCheckResult .
  op {_,_,_} : State CESubstitution RuleName -> Transition [ctor] .
  op nil : -> TransitionList [ctor] .
  op __ : TransitionList TransitionList -> TransitionList [ctor assoc id: nil format (d ni d)] .
  op prefix_loop_ : TransitionList TransitionList -> ModelCheckResult [ctor format(n n++i n ni i--)] .

*** State set
  sorts StateSet .
  subsort State < StateSet .
  op _\/_ : StateSet StateSet -> StateSet [ctor assoc comm prec 121] .
endfm


**************************************************
***    Logical Model Checker on META-LEVEL     ***
**************************************************

--- core maude search function (using META-LEVEL)
fmod BOUNDED-FOLDING-MODEL-CHECKER is
  pr RULE-NAME .
  pr META-LEVEL .
  pr SATISFACTION .
  including LTL .

--- meta transition
  sorts MetaEdge MetaConf .
  op deadlock : -> MetaEdge [ctor] .
  op -[_]/_- : Substitution RuleName -> MetaEdge [ctor] .
  op <_> : State -> MetaConf [ctor] .
  op _|=>_ : MetaEdge State -> MetaConf [ctor] .

--- propositions
  subsort Prop < Formula .
  op prop : Term -> Prop [ctor] .

--- folding relation
  op _>=_ : State State -> Bool .
  op _~=_ : State State -> Bool .

  op _~_  : MetaEdge MetaEdge -> Bool .
  eq deadlock ~ deadlock = true .

--- print state during model checking (debugging purpose)
  op prettyPrint : State ~> QidList .
  op prettyPrint : MetaEdge ~> QidList .

--- transitions
  sort Transition TransitionList .
  subsort Transition < TransitionList .
  op {_,_} : State MetaEdge -> Transition [ctor] .
  op nil : -> TransitionList [ctor] .
  op __ : TransitionList TransitionList -> TransitionList [ctor assoc id: nil format (d ni d)] .

--- model checking results
  sorts ModelCheckResult .
  subsort Bool < ModelCheckResult .
  op prefix_loop_ : TransitionList TransitionList -> ModelCheckResult [ctor format(n n++i n ni i--)] .

--- bounded model checker report
  sort BoundedModelCheckReport .
  op result:_real:_bound:_complete:_ : ModelCheckResult Bool Nat Bool -> BoundedModelCheckReport [ctor] .

--- Pre-condition: InitState is a State, Phi is a Formula, SubsumptionFolding is a Bool, and Bound is a Bound.
--- Post-condition: Performs symbolic bounded model checking and returns a BoundedModelCheckReport.
--- Author: Kyungmin Bae
--- Date: 2024/12/24
  op symbolicModelCheck : State Formula Bool Bound ~> BoundedModelCheckReport
    [special (
      id-hook SymbolicModelCheckerSymbol

      --- temporal operators
      op-hook trueSymbol              (True : ~> Formula)
      op-hook falseSymbol             (False : ~> Formula)
      op-hook notSymbol               (~_ : Formula ~> Formula)
      op-hook nextSymbol              (O_ : Formula ~> Formula)
      op-hook andSymbol               (_/\_ : Formula Formula ~> Formula)
      op-hook orSymbol                (_\/_ : Formula Formula ~> Formula)
      op-hook untilSymbol             (_U_ : Formula Formula ~> Formula)
      op-hook releaseSymbol           (_R_ : Formula Formula ~> Formula)

      --- for Bound attribute
      op-hook succSymbol              (s_ : Nat ~> NzNat)
      op-hook unboundedSymbol         (unbounded : ~> Bound)

      --- state propositions
      op-hook satisfiesSymbol         (_|=_ : State Formula ~> Bool)
      term-hook trueTerm              (true)

      --- folding graph stuff
      op-hook subsumeFoldingRelSymbol (_>=_ : State State ~> Bool)
      op-hook renameFoldingRelSymbol  (_~=_ : State State ~> Bool)
      op-hook compatibleTransSymbol   (_~_  : MetaEdge MetaEdge ~> Bool)

      op-hook prettyPrintStateSymbol  (prettyPrint : State ~> QidList)
      op-hook prettyPrintTransSymbol  (prettyPrint : MetaEdge ~> QidList)

      --- meta graph
      op-hook metaStateSymbol         (<_> : State ~> MetaConf)
      op-hook metaTransitionSymbol    (_|=>_ : MetaEdge State ~> MetaConf)

      --- counterexamples
      term-hook falseTerm             (false)
      term-hook deadlockTerm          ((deadlock).MetaEdge)

      op-hook transitionSymbol        ({_,_} : State MetaEdge ~> Transition)
      op-hook transitionListSymbol    (__ : TransitionList TransitionList ~> TransitionList)
      op-hook nilTransitionListSymbol (nil : ~> TransitionList)
      op-hook counterexampleSymbol    (prefix_loop_ : TransitionList TransitionList ~> ModelCheckResult)

      --- result report
      op-hook resultreportSymbol      (result:_real:_bound:_complete:_ : ModelCheckResult Bool Nat Bool ~> BoundedModelCheckReport) 
     )] .
endfm


**********************************
***  Meta Narrowing Connector  ***
**********************************

load full-maude321

fmod META-LMC-PARAMETERS is 
  pr META-MODULE .
  op ##m## : ~> SModule [memo] . --- empty! the user module shoule define them.
  op ##f## : ~> TermList [memo] .
  op ##initCPT## : ~> CompletenessSet [memo] . --- initial constraint incompleteness; user module should define this when needed

  eq ##initCPT## = undefined .

  var H : Header .  
  var IL : ImportList .  
  var ME : ModuleExpression .
  var SS : SortSet .  
  var SSDS : SubsortDeclSet .  
  var OPDS : OpDeclSet . 
  var MAS : MembAxSet .  
  var EQS : EquationSet .  
  var RLS : RuleSet .
  var STDS : StratDeclSet .
  var STDFS : StratDefSet .

--- Pre-condition: ME is a ModuleExpression and M is an SModule.
--- Post-condition: Returns an SModule with the imports from ME added to M.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
  op addImport : ModuleExpression SModule -> SModule [memo] .
  eq addImport(ME, mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm)
    = mod H is IL (including ME .) sorts SS . SSDS OPDS MAS EQS RLS endm .  

--- Pre-condition: M is a Module.
--- Post-condition: Returns an SModule by removing all strategy declarations from M.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
  op trMod : Module -> SModule [memo] . 
  eq trMod(smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm)
   = mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm .
  eq trMod(M:Module) = M:Module [owise] .
endfm

fmod LMC-RESULT-SET is
  pr FM-RESULT-CONTEXT-SET .
  pr RULE-NAME .

  sort StepResult StepResult? .
  subsort StepResult < StepResult? .
  op failure : -> StepResult? [ctor] .
  op {_,_,_|_} : Term Substitution RuleName Term -> StepResult [ctor] .

  sort StepResultSet .
  subsort StepResult < StepResultSet .
  op empty : -> StepResultSet [ctor] .
  op _||_ : StepResultSet StepResultSet -> StepResultSet
    [ctor assoc comm id: empty prec 65] .
  eq X:StepResult || X:StepResult = X:StepResult .

  var M : Module . 
  var S : Substitution .
  vars T ST : Term . 
  var TP : Type . 
  var R : Rule .
  var Tr : TraceNarrow . 
  var SRS : StepResultSet .
  var RN : RuleName .

  op _|>_ : StepResult Term -> StepResult .
  eq empty |> T = (empty).StepResult .
  eq ({ST,S,RN | T} || SRS) |> T = {ST,(S |> T),RN | T} || (SRS |> T) .
  eq (failure || SRS) |> T = failure || (SRS |> T) .

  sort VariantSet .
  subsort Variant < VariantSet .
  op emptyVariantSet : -> VariantSet [ctor] .
  op _#_ : VariantSet VariantSet -> VariantSet
    [ctor assoc comm id: emptyVariantSet prec 65 format (d d n d)] .
  eq X:Variant # X:Variant = X:Variant .
endfm

fmod RULE-TERM-RENAMING is
    pr META-LEVEL .
    pr INT .
    pr STRING .
    pr CONVERSION .

    sort VarIndices .
    op {_,_,_,_} : String Nat Nat Nat -> VarIndices [ctor] .
    op fail : -> VarIndices [ctor] .
    op __ : VarIndices VarIndices -> VarIndices [assoc comm ctor id: fail] .

    vars P C L : Nat .
    vars S Prf : String .

--- Pre-condition: S is a String and Prf is a String.
--- Post-condition: Attempts to find indices of a variable with a given prefix (#, %, or @) in the string S. Returns VarIndices containing the prefix, start, colon, and length, or fail if not found.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op findVarIndices : String String -> VarIndices .
    ceq findVarIndices(S, Prf) = {Prf,P,C,L} if P := rfind(S, Prf, length(S)) /\ C := rfind(S, ":", length(S)) /\ L := length(S) /\ P + 1 < C /\ C + 1 < L .
    eq findVarIndices(S, Prf) = fail [owise] .

    var V : Variable .
    var NS : String .
    var N : Nat .
    var VIS : VarIndices .

--- Pre-condition: S is a String and VIS is a VarIndices.
--- Post-condition: Renames a variable string based on its indices, prefixing it and ensuring it's a valid Maude variable name.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op renameVarString : String VarIndices -> String .
    ceq renameVarString(S, {Prf,P,C,L} VIS) = Prf + Prf + NS + ":" + substr(S, C + 1, L + (- 1))
      if NS := substr(S, P + 1, C + (- 1)) /\ N := rat(NS, 10) .
    eq renameVarString(S, VIS) = S [owise] .

--- Pre-condition: TL is a TermList or a Term.
--- Post-condition: Collects all variable indices from the term or the terms in the TermList.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op collectVarIndices : TermList -> VarIndices .
    eq collectVarIndices(empty) = fail .
    ceq collectVarIndices((T:Term, TL:TermList)) = collectVarIndices(T:Term) collectVarIndices(TL:TermList) if TL:TermList =/= empty .

    op collectVarIndices : Term -> VarIndices .
    eq collectVarIndices(C:Constant) = fail .
    eq collectVarIndices(F:Qid[TL:TermList]) = collectVarIndices(TL:TermList) .
    eq collectVarIndices(V) = findVarIndices(string(V), "#") findVarIndices(string(V), "%") findVarIndices(string(V), "@") .
    
--- Pre-condition: TL is a TermList.
--- Post-condition: Renames the terms in the TermList to ensure valid Maude variable names.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op renameRuleTerms : TermList -> TermList .
    eq renameRuleTerms(empty) = empty .
    eq renameRuleTerms((T:Term, TL:TermList)) = renameRuleTerm(T:Term), renameRuleTerms(TL:TermList) .

--- Pre-condition: T is a Term.
--- Post-condition: Renames the term to ensure valid Maude variable names.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24    
    op renameRuleTerm : Term -> Term .
    eq renameRuleTerm(C:Constant) = C:Constant .
    eq renameRuleTerm(F:Qid[TL:TermList]) = F:Qid[renameRuleTerms(TL:TermList)] .
    eq renameRuleTerm(V) = qid(renameVarString(string(V), findVarIndices(string(V), "#") findVarIndices(string(V), "%") findVarIndices(string(V), "@"))) .

    sort Qid? .
    subsort Qid < Qid? .
    op noInternalPrefix : -> Qid? [ctor] .

--- Pre-condition: VIS is a VarIndices / T is a Term
--- Post-condition: Attempts to find the internal prefix (#, %, or @) of a variable based on its indices or within the term.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op findInternalPrefix : VarIndices -> Qid? .
    eq findInternalPrefix({Prf,P,C,L} VIS) = qid(Prf) .
    eq findInternalPrefix(VIS) = noInternalPrefix [owise] .

    op findInternalPrefix : Term -> Qid? .
    eq findInternalPrefix(T:Term) = findInternalPrefix(collectVarIndices(T:Term)) .
endfm

fmod COMPLETENESS-DECLARATION is
    pr SATISFACTION .
    pr COMPLETENESS .

    sorts CompletenessMapData CompletenessMap CompletenessKey .
    op %prop : Qid -> CompletenessKey [ctor] .
    op %operator : Qid -> CompletenessKey [ctor] .
    op _=>_ : CompletenessKey CompletenessSet -> CompletenessMapData [ctor prec 45] . 

    op nil : -> CompletenessMapData [ctor] .
    op _;_ : CompletenessMapData CompletenessMapData -> CompletenessMapData [assoc comm ctor prec 50 id: nil] .
    op empty : -> CompletenessMap [ctor] .
    op {_} : CompletenessMapData -> CompletenessMap [ctor] .

    sort MaybeBool .
    subsort Bool < MaybeBool .
    op unknown : -> MaybeBool .

    var M : Module .
    vars T T' ST BT PT IT : Term .
    var TL : TermList .
    var CK : CompletenessKey .
    vars CS CS' : CompletenessSet .
    var CM : CompletenessMapData .
    vars B B' : Bool .
    var OPDS : OpDeclSet .
    var EQS : EquationSet .
    var ATRS : AttrSet .

--- Pre-condition: CS is a CompletenessSet.
--- Post-condition: Returns a CompletenessSet with both complete and incomplete variants for each boolean value in the input set.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op fillCompleteness : CompletenessSet -> CompletenessSet .
    eq fillCompleteness(complete(B)) = complete(B), incomplete(not B) .
    eq fillCompleteness(incomplete(B)) = complete(not B), incomplete(B) .
    eq fillCompleteness(CS) = CS [owise] .

--- Pre-condition: CK is a CompletenessKey, CS is a CompletenessSet, and CM is a CompletenessMap.
--- Post-condition: Inserts or updates the CompletenessSet associated with the CompletenessKey in the CompletenessMap.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op insert : CompletenessKey CompletenessSet CompletenessMap -> CompletenessMap .
    eq insert(CK, CS, empty) = { CK => CS } .
    eq insert(CK, CS, { CK => CS' ; CM }) = { CK => (CS', CS) ; CM } .
    eq insert(CK, CS, { CM }) = { CK => CS ; CM } [owise] .

--- Pre-condition: CK is a CompletenessKey, CM is a CompletenessMap, and B is a Bool.
--- Post-condition: Tests if the CompletenessMap contains a completeness entry for the given key and boolean value.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op testFor : CompletenessKey CompletenessMap Bool -> MaybeBool .
    eq testFor(CK, {CK => (complete(B), CS) ; CM}, B) = true .
    eq testFor(CK, {CK => (incomplete(B), CS) ; CM}, B) = false .
    eq testFor(CK, CM:CompletenessMap, B) = unknown [owise] .

    op errorTerm : -> [Term] .

--- Pre-condition: M is a Module, OPDS is an OpDeclSet, and EQS is an EquationSet.
--- Post-condition: Extracts completeness information from the metadata of operator declarations in the module.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op declaredCompleteness : Module OpDeclSet EquationSet -> CompletenessMap .
    eq declaredCompleteness(M, (op O:Qid : TYL:TypeList -> 'Prop [metadata("incomplete(true)") ATRS].) OPDS, EQS) = insert(%prop(O:Qid), fillCompleteness(incomplete(true)), declaredCompleteness(M, OPDS, EQS)) .
    eq declaredCompleteness(M, (op O:Qid : TYL:TypeList -> 'Prop [metadata("incomplete(false)") ATRS].) OPDS, EQS) = insert(%prop(O:Qid), fillCompleteness(incomplete(false)), declaredCompleteness(M, OPDS, EQS)) .
    eq declaredCompleteness(M, (op O:Qid : TYL:TypeList -> 'Prop [metadata("incomplete(both)") ATRS].) OPDS, EQS) = insert(%prop(O:Qid), fillCompleteness((incomplete(true), incomplete(false))), declaredCompleteness(M, OPDS, EQS)) .
    ceq declaredCompleteness(M, (op O:Qid : TYL:TypeList -> TY:Type [metadata("incomplete(true)") ATRS].) OPDS, EQS) = insert(%operator(O:Qid), fillCompleteness(incomplete(true)), declaredCompleteness(M, OPDS, EQS)) if TY:Type =/= 'Prop .
    ceq declaredCompleteness(M, (op O:Qid : TYL:TypeList -> TY:Type [metadata("incomplete(false)") ATRS].) OPDS, EQS) = insert(%operator(O:Qid), fillCompleteness(incomplete(false)), declaredCompleteness(M, OPDS, EQS)) if TY:Type =/= 'Prop .
    ceq declaredCompleteness(M, (op O:Qid : TYL:TypeList -> TY:Type [metadata("incomplete(both)") ATRS].) OPDS, EQS) = insert(%operator(O:Qid), fillCompleteness((incomplete(true), incomplete(false))), declaredCompleteness(M, OPDS, EQS)) if TY:Type =/= 'Prop .
    
    eq declaredCompleteness(M, OPDS, EQS) = empty [owise] .

    op declaredCompleteness : Module -> CompletenessMap [memo] .
    eq declaredCompleteness(M) = declaredCompleteness(M, getOps(M), getEqs(M)) .

--- Pre-condition: M is a Module, O is a Qid, and B is a Bool.
--- Post-condition: Checks if a proposition with the given Qid is declared as complete for the given boolean value in the module's metadata.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op isPropCompleteFor : Module Qid Bool -> MaybeBool .
    eq isPropCompleteFor(M, O:Qid, B) = testFor(%prop(O:Qid), declaredCompleteness(M), B) .

--- Pre-condition: M is a Module, O is a Qid, and B is a Bool.
--- Post-condition: Checks if an operator with the given Qid is declared as complete for the given boolean value in the module's metadata.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op isOpCompleteFor : Module Qid Bool -> MaybeBool .
    eq isOpCompleteFor(M, O:Qid, B) = testFor(%operator(O:Qid), declaredCompleteness(M), B) .
      
--- Pre-condition: M is a Module, T is a Term, and B is a Bool.
--- Post-condition: Checks if a term is marked as incomplete for a specific boolean value using meta-reduction.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24      
    op isMarkedIncomplete : Module Term Bool -> Bool .
    eq isMarkedIncomplete(M, T, B) = getTerm(metaReduce(M, 'find[T, upTerm(B)])) == 'incomplete[upTerm(B)] .
endfm

fmod CONSTRAINT-INCOMPLETENESS is
  pr META-LEVEL .
  pr COMPLETENESS .
  pr COMPLETENESS-DECLARATION .
  pr META-LMC-PARAMETERS .

  var M : Module .
  var Q : Qid .
  vars T T1 T2 : Term .
  var TL : TermList .
  var B : Bool .
  var PROP : Constant .

  --- Semantics:
  --- - incomplete(true)  : the constraint itself is incomplete
  --- - incomplete(false) : the negation of the constraint is incomplete
  op propConstraintIncompleteness : Module Qid -> CompletenessSet .
  ceq propConstraintIncompleteness(M, Q) = incomplete(true), incomplete(false)
    if isPropCompleteFor(M, Q, true) = false /\ isPropCompleteFor(M, Q, false) = false .
  ceq propConstraintIncompleteness(M, Q) = incomplete(true)
    if isPropCompleteFor(M, Q, true) = false .
  ceq propConstraintIncompleteness(M, Q) = incomplete(false)
    if isPropCompleteFor(M, Q, false) = false .
  eq propConstraintIncompleteness(M, Q) = undefined [owise] .

  op opConstraintIncompleteness : Module Qid -> CompletenessSet .
  ceq opConstraintIncompleteness(M, Q) = incomplete(true), incomplete(false)
    if isOpCompleteFor(M, Q, true) = false /\ isOpCompleteFor(M, Q, false) = false .
  ceq opConstraintIncompleteness(M, Q) = incomplete(true)
    if isOpCompleteFor(M, Q, true) = false .
  ceq opConstraintIncompleteness(M, Q) = incomplete(false)
    if isOpCompleteFor(M, Q, false) = false .
  eq opConstraintIncompleteness(M, Q) = undefined [owise] .

  op termIncompletenessRaw : Module Term -> CompletenessSet .
  op termIncompletenessRaw : Module TermList -> CompletenessSet .

  eq termIncompletenessRaw(M, 'true.Bool) = undefined .
  eq termIncompletenessRaw(M, 'false.Bool) = undefined .

  --- boolean connectives
  eq termIncompletenessRaw(M, '_and_[TL]) = termIncompletenessRaw(M, TL) .
  eq termIncompletenessRaw(M, '_or_[TL]) = termIncompletenessRaw(M, TL) .
  eq termIncompletenessRaw(M, '_<=>_[T1, T2]) = termIncompletenessRaw(M, T1), termIncompletenessRaw(M, T2) .

  --- proposition evaluation
  eq termIncompletenessRaw(M, '_|=_[T, PROP]) = propConstraintIncompleteness(M, getName(PROP)), termIncompletenessRaw(M, T) .

  --- operator evaluation that returns a Bool
  eq termIncompletenessRaw(M, Q[TL]) = opConstraintIncompleteness(M, Q), termIncompletenessRaw(M, TL) .

  eq termIncompletenessRaw(M, T) = undefined [owise] .

  eq termIncompletenessRaw(M, empty) = undefined .
  eq termIncompletenessRaw(M, (T, TL)) = termIncompletenessRaw(M, T), termIncompletenessRaw(M, TL) .

  op constraintIncompleteness : Module Term -> CompletenessSet .
  eq constraintIncompleteness(M, T) = termIncompletenessRaw(M, T), ##initCPT## .
endfm

fmod RULE-PROP-CONF is
    pr QID .
    pr COMPLETENESS .

    sort PropEval .

    op genVariants : -> PropEval [ctor] . --- Signifies that variant generation is needed for its corresponding proposition
    op incomplete : Bool Completeness -> PropEval [ctor] .

    sort PropEvalSet .
    subsort PropEval < PropEvalSet .
    op emptyPropEvalSet : -> PropEvalSet [ctor] .
    op __ : PropEvalSet PropEvalSet -> PropEvalSet [assoc ctor comm id: emptyPropEvalSet] .
    eq PE:PropEval PE:PropEval = PE:PropEval .

    sorts PropEvalMap PropEvalMapping .
    subsort PropEvalMapping < PropEvalMap .

    op emptyPropEvalMap : -> PropEvalMap [ctor] .
    op _*>_ : Qid PropEvalSet -> PropEvalMapping .
    op __ : PropEvalMap PropEvalMap -> PropEvalMap [assoc ctor comm id: emptyPropEvalMap] .

    sorts RulePropConf RulePropConfSet .
    subsort PropEvalMapping < RulePropConf .
    op emptyRulePropConf : -> RulePropConf [ctor] .
    op _,_ : RulePropConf RulePropConf -> RulePropConf [assoc ctor comm id: emptyRulePropConf] .

    subsort RulePropConf < RulePropConfSet .
    op emptyRulePropConfSet : -> RulePropConfSet [ctor] .
    op _;_ : RulePropConfSet RulePropConfSet -> RulePropConfSet [assoc ctor comm id: emptyRulePropConfSet] .
endfm

fmod PROP-INFO-EXTRACTION is
    pr RULE-PROP-CONF .
    pr COMPLETENESS-DECLARATION .
    pr META-LEVEL .

    var Q : Qid .
    var M : Module .
    vars T ST BT PT : Term .
    vars TL TL1 TL2 TL3 : TermList .
    
    var PROP : Constant .

    var TYL : TypeList .
    var EQS : EquationSet .
    var OPDS : OpDeclSet .
    var ATRS : AttrSet .

    var PE : PropEval .
    var PES : PropEvalSet .
    var PEM : PropEvalMapping .
    var PEMm : PropEvalMap .

    var RPC : RulePropConf .
    var RPCS : RulePropConfSet .

    vars B B' : Bool .

    op toPropTerm : Qid -> Term .
    eq toPropTerm(Q) = qid(string(Q) + ".Prop") .

    op dedup : TermList -> TermList .
    eq dedup((TL1, T, TL2, T, TL3)) = dedup((TL1, T, TL2, TL3)) .
    eq dedup(TL) = TL [owise] .

--- Pre-condition: M is a Module, Q is a Qid, and B is a Bool.
--- Post-condition: Determines the incompleteness Completeness value based on whether the negation of the proposition is declared complete in the module.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op negationIncompleteness : Module Qid Bool -> Completeness .
    ceq negationIncompleteness(M, Q, B) = incomplete(not B) if B' := isPropCompleteFor(M, Q, not B) /\ not B' .
    eq negationIncompleteness(M, Q, B) = complete(not B) [owise] .

    op getIncompleteness : Module Qid Bool -> PropEvalSet .
    ceq getIncompleteness(M, Q, B) = incomplete(B, negationIncompleteness(M, Q, B)) if B' := isPropCompleteFor(M, Q, B) /\ not B' .
    eq getIncompleteness(M, Q, B) = emptyPropEvalSet [owise] .

    op getPropIncompletes : Module Qid -> PropEvalSet .
    eq getPropIncompletes(M, Q) = getIncompleteness(M, Q, true) getIncompleteness(M, Q, false) .

    op getVariantEval : Qid EquationSet -> PropEvalSet .
    ceq getVariantEval(Q, (eq '_|=_[ST, PROP] = BT [variant ATRS] .) EQS) = genVariants if getName(PROP) = Q .
    eq getVariantEval(Q, EQS) = emptyPropEvalSet [owise] .

    op getPropInfo : Module TermList EquationSet -> PropEvalMap .
    ceq getPropInfo(M, (T, TL), EQS) = (Q *> getPropIncompletes(M, Q) getVariantEval(Q, EQS)) getPropInfo(M, TL, EQS) if Q := getName(T) .
    eq getPropInfo(M, TL, EQS) = emptyPropEvalMap [owise] .

    op getPropInfo : Module TermList -> PropEvalMap .
    eq getPropInfo(M, TL) = getPropInfo(M, dedup(TL), getEqs(M)) .

    op insertPropInfo : PropEvalMapping RulePropConfSet -> RulePropConfSet .
    eq insertPropInfo(PEM, emptyRulePropConfSet) = emptyRulePropConfSet .
    eq insertPropInfo(PEM, RPC ; RPCS) = (PEM, RPC) ; insertPropInfo(PEM, RPCS) .

--- Pre-condition: PEM is a PropEvalMap.
--- Post-condition: Generates the cross product of PropEvalMappings, creating a RulePropConfSet representing all combinations of proposition evaluations.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op crossPropInfo : PropEvalMap -> RulePropConfSet .
    eq crossPropInfo(emptyPropEvalMap) = emptyRulePropConfSet .
    eq crossPropInfo((Q *> emptyPropEvalSet) PEMm) = emptyRulePropConfSet .
    eq crossPropInfo((Q *> PE PES)) = (Q *> PE) ; crossPropInfo((Q *> PES)) .
    eq crossPropInfo((Q *> PE PES) PEMm) = crossPropInfo((Q *> PES) PEMm) ; insertPropInfo((Q *> PE), crossPropInfo(PEMm)) .
endfm

fmod VARIANT-GENERATION is
    pr META-LEVEL .

    sorts VariantPair VariantPairSet .
    subsort VariantPair < VariantPairSet .

    op empty : -> VariantPairSet [ctor] .
    op {_,_} : Term Substitution -> VariantPair [ctor] .
    op _#_ : VariantPairSet VariantPairSet -> VariantPairSet [assoc comm ctor id: empty] .

    vars Q Q' : Qid .
    var M : Module .
    vars T T' : Term .
    var N : Nat .
    var SUB : Substitution .
    var B : Bool .

    var VARS : VariantPairSet .

    op getVariantSet : Module Term Nat Qid Variant? -> VariantPairSet .
    eq getVariantSet(M, T, N, Q, {T',SUB,Q',P:Parent,B}) = {T',SUB} # getVariantSet(M, T, s N, Q) .
    eq getVariantSet(M, T, N, Q, VV:Variant?) = empty [owise] .

    op getVariantSet : Module Term Nat Qid -> VariantPairSet .
    eq getVariantSet(M, T, N, Q) = getVariantSet(M, T, N, Q, metaGetIrredundantVariant(M, T, empty, Q, N)) .

    op getVariantSet : Module Term Qid -> VariantPairSet .
    eq getVariantSet(M, T, Q) = getVariantSet(M, T, 0, Q) .
endfm

fmod RULE-EXPANSION is
    pr RULE-TERM-RENAMING .
    pr PROP-INFO-EXTRACTION .
    pr VARIANT-GENERATION .
    
    var Q : Qid .
    vars M M' : Module .
    vars T T1 T2 ST ST' PT PT' CT CT' : Term .
    vars TL PTs CTs CTs' : TermList .
    vars B B' : Bool .
    var SUB : Substitution .

    var TY : Type .
    var TYL : TypeList .
    var RL : Rule .
    vars COND COND' : Condition .

    var IL : ImportList .
    var SS : SortSet .
    var SSDS : SubsortDeclSet .
    var OPDS : OpDeclSet .
    var MAS : MembAxSet .
    var EQS : EquationSet .
    var RLS : RuleSet .
    var ATRS : AttrSet .

    var VARS : VariantPairSet .
    var RPC : RulePropConf .
    var RPCS : RulePropConfSet .

    var CS : CompletenessSet .

    var CP : Completeness .
  
    op toPropTerm : Qid -> Term .
    eq toPropTerm(Q) = qid(string(Q) + ".Prop") .

    op conditionToTerm : Condition -> Term .
    eq conditionToTerm(T1 = T2) = '_<=>_[T1, T2] .
    ceq conditionToTerm(COND /\ COND') = '_and_[conditionToTerm(COND), conditionToTerm(COND')] if COND =/= nil /\ COND' =/= nil .
    eq conditionToTerm(COND) = 'true.Bool [owise] .

    op errorBool : -> Bool .
    op conditionCompleteness : Module Condition -> CompletenessSet .
    ceq conditionCompleteness(M, Q[TL] = T) = incomplete(B) if B := downTerm(T, errorBool) /\ isOpCompleteFor(M, Q, B) = false .
    ceq conditionCompleteness(M, COND /\ COND') = conditionCompleteness(M, COND), conditionCompleteness(M, COND') if COND =/= nil /\ COND' =/= nil .
    eq conditionCompleteness(M, COND) = undefined .

--- Pre-condition: ST is a Term and RPC is a RulePropConf.
--- Post-condition: Crafts a PropMap term based on the RulePropConf, instantiating propositions with their corresponding boolean values or generating variants if needed.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24    
    op craftPropMap : Term RulePropConf -> Term .
    eq craftPropMap(ST, ((Q *> genVariants), RPC)) = '__['_*>_[toPropTerm(Q), '_|=_[ST, toPropTerm(Q)]], craftPropMap(ST, RPC)] .
    eq craftPropMap(ST, ((Q *> incomplete(B, CP)), RPC)) = '__['_*>_[toPropTerm(Q), upTerm(B)], craftPropMap(ST, RPC)] .
    eq craftPropMap(ST, RPC) = 'emptyPropMap.PropMap [owise] .

--- Pre-condition: ST is a Term, CT is a Term, COND is a Condition, and RPC is a RulePropConf.
--- Post-condition: Crafts constraints (a boolean term) based on the RulePropConf and the given condition, linking proposition values to their expected truth values.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24    
    op craftConstraints : Term Term Condition RulePropConf -> Term . 
    eq craftConstraints(ST, CT, COND, ((Q *> incomplete(B, CP)), RPC)) = '_and_[('_<=>_['_|=_[ST, toPropTerm(Q)], upTerm(B)]), craftConstraints(ST, CT, COND, RPC)] .
    eq craftConstraints(ST, CT, COND, RPC) = '_and_[conditionToTerm(COND), CT] [owise] .

--- Pre-condition: CPT is a Term, RPC is a RulePropConf, and CS is a CompletenessSet.
--- Post-condition: Crafts a CompletenessSet term by updating the provided CompletenessSet with information from the RulePropConf.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24    
    op craftCompleteness : Term RulePropConf CompletenessSet -> Term .
    eq craftCompleteness(CPT, ((Q *> incomplete(B, complete(B'))), RPC), CS) = 'update[craftCompleteness(CPT, RPC, CS), 'incomplete['true.Bool]] .
    eq craftCompleteness(CPT, ((Q *> incomplete(B, incomplete(B'))), RPC), CS) = 'update[craftCompleteness(CPT, RPC, CS), '_`,_['incomplete['true.Bool], 'incomplete['false.Bool]]] .
    eq craftCompleteness(CPT, RPC, CS) = 'update[CPT, upTerm(CS)] [owise] .

--- Pre-condition: M is a Module, VARS is a VariantPairSet, and ATRS is an AttrSet.
--- Post-condition: Generates a RuleSet by instantiating rules based on the provided variants and attributes.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24   
    op generateRules : Module VariantPairSet AttrSet -> RuleSet .
    eq generateRules(M, empty, ATRS) = none .
    ceq generateRules(M, {T,SUB} # VARS, ATRS) = (rl '`{`{`{_|_|_`}`}`}[ST, PT, CT] => '`{`{`{_|_|_`}`}`}[ST', PT', CT'] [ATRS] .)
                                                 generateRules(M, VARS, ATRS)
      if 'exRule[ST,PT,CT,ST',PT',CT'] := renameRuleTerm(T) /\ getTerm(metaReduce(M, 'isComplete[PT'])) = 'true.Bool /\ CT' =/= 'false.Bool .
    eq generateRules(M, {T,SUB} # VARS, ATRS) = generateRules(M, VARS, ATRS) [owise] .    

--- Pre-condition: M is a Module, VARS is a VariantPairSet, and ATRS is an AttrSet.
--- Post-condition: Generates a RuleSet for initial states by instantiating rules based on the provided variants and attributes.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24   
    op generateInitRules : Module VariantPairSet AttrSet -> RuleSet .
    eq generateInitRules(M, empty, ATRS) = none .
    ceq generateInitRules(M, {T,SUB} # VARS, ATRS) = (rl '<<<_|_>>>[ST,CT] => '`{`{`{_|_|_`}`}`}[ST, PT, CT'] [ATRS] .)
                                                     generateInitRules(M, VARS, ATRS)
      if 'exInitRule[ST,CT,PT,CT'] := renameRuleTerm(T) /\ getTerm(metaReduce(M, 'isComplete[PT])) = 'true.Bool /\ CT' =/= 'false.Bool .
    eq generateInitRules(M, {T,SUB} # VARS, ATRS) = generateInitRules(M, VARS, ATRS) [owise] .

    op isNarrowingRule : AttrSet -> Bool .
    eq isNarrowingRule(metadata("narrowing") ATRS) = true .
    eq isNarrowingRule(ATRS) = false [owise] .

    --- Shared builders for expanded rule components (used by expandRule/expandInitRule)
    op buildExpandedPropMap : Term RulePropConf -> Term .
    eq buildExpandedPropMap(ST, RPC) = craftPropMap(ST, RPC) .

    op buildExpandedConstraint : Term Term Condition RulePropConf -> Term .
    eq buildExpandedConstraint(ST, CT, COND, RPC) = craftConstraints(ST, CT, COND, RPC) .

    --- Build RuleSet for one expanded configuration (normal rule)
    op expandOneRule : Module Term Term Condition AttrSet RulePropConf -> RuleSet .
    ceq expandOneRule(M, ST, ST', nil, ATRS, RPC) =
      generateRules(M,
        getVariantSet(M,
          'exRule[ST, '##PT:PropMap, '##CT:Bool,
                 ST', PT', CT'], '@),
        narrowing ATRS)
      if PT' := buildExpandedPropMap(ST', RPC) /\
         CT' := buildExpandedConstraint(ST', '##CT:Bool, nil, RPC) .

    ceq expandOneRule(M, ST, ST', COND, ATRS, RPC) =
      generateRules(M,
        getVariantSet(M,
          'exRule[ST, '##PT:PropMap, '##CT:Bool,
                 ST', PT', CT'], '@),
        narrowing ATRS)
      if isNarrowingRule(ATRS) /\
         PT' := buildExpandedPropMap(ST', RPC) /\
         CT' := buildExpandedConstraint(ST', '##CT:Bool, COND, RPC) .

    --- Build RuleSet for one expanded configuration (init rule)
    op expandOneInitRule : Module RulePropConf -> RuleSet .
    ceq expandOneInitRule(M, RPC) =
      generateInitRules(M,
        getVariantSet(M,
          'exInitRule['##ST:State, '##CT:Bool,
                     PT', CT'], '@),
        narrowing)
      if PT' := buildExpandedPropMap('##ST:State, RPC) /\
         CT' := buildExpandedConstraint('##ST:State, '##CT:Bool, nil, RPC) .

--- Pre-condition: M is a Module, RL is a Rule, and RPCS is a RulePropConfSet.
--- Post-condition: Expands a given rule based on the provided RulePropConfSet, generating new rules for each possible proposition instantiation.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24   
    op expandRule : Module Rule RulePropConfSet -> RuleSet .
    ceq expandRule(M, (rl ST => ST' [narrowing ATRS] .), RPC ; RPCS) =
        RLS expandRule(M, (rl ST => ST' [narrowing ATRS] .), RPCS)
      if RLS := expandOneRule(M, ST, ST', nil, narrowing ATRS, RPC) .      
    ceq expandRule(M, (crl ST => ST' if COND [ATRS] .), RPC ; RPCS) =
        RLS expandRule(M, (crl ST => ST' if COND [ATRS] .), RPCS)
      if RLS := expandOneRule(M, ST, ST', COND, ATRS, RPC) .
    eq expandRule(M, RL, RPCS) = none [owise] .

--- Pre-condition: M is a Module and RPCS is a RulePropConfSet.
--- Post-condition: Expands initial state rules based on the provided RulePropConfSet, generating new initial state rules for each possible proposition instantiation.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24   
    op expandInitRule : Module RulePropConfSet -> RuleSet .
    eq expandInitRule(M, emptyRulePropConfSet) = none .
    ceq expandInitRule(M, RPC ; RPCS) = RLS expandInitRule(M, RPCS)
      if RLS := expandOneInitRule(M, RPC) .

    op expandRuleSet : Module RuleSet RulePropConfSet -> RuleSet .
    eq expandRuleSet(M, none, RPCS) = none .
    eq expandRuleSet(M, RL RLS, RPCS) = expandRule(M, RL, RPCS) expandRuleSet(M, RLS, RPCS) .

--- Pre-condition: M is a Module and TL is a TermList.
--- Post-condition: Expands the rules in a module based on the provided term list (which typically represents initial states or relevant terms for property analysis), generating a new module with expanded rules.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24   
    op expandRules : Module TermList -> Module [memo] .
    ceq expandRules(M, TL) = (mod Q is IL sorts SS . SSDS OPDS MAS EQS 
                                expandInitRule(M, RPCS) expandRuleSet(M, RLS, RPCS)
                              endm) 
      if mod Q is IL sorts SS . SSDS OPDS MAS EQS RLS endm := M /\ RPCS := crossPropInfo(getPropInfo(M, TL)) .
endfm
---

mod META-LMC-THEORY is
  pr LMC-RESULT-SET .
  pr META-LMC-PARAMETERS .
  pr BOUNDED-FOLDING-MODEL-CHECKER .

  vars T ST ST' : Term . 
  vars SUB SUB' : Substitution .  
  var SRS : StepResultSet . 
  var RN : RuleName .

  ops init mid : Term -> State [ctor] .

--- functions
  ops next initVariant : Term -> StepResultSet .

--- meta rules
 crl [init] : < init(ST) > => -[SUB']/ RN - |=> mid(ST')
   if {ST',SUB',RN | T} || SRS := initVariant(ST) .

 crl [mid]  :  < mid(ST) > 
           => -[SUB']/ RN - |=> mid(ST')
  if {ST',SUB',RN | T} || SRS := next(ST) .
endm

fmod META-NARROWING-INTERFACE is
  pr META-LMC-PARAMETERS .
  pr LMC-RESULT-SET .
  pr VARIANT-GENERATION .
  pr COMPLETENESS-DECLARATION .

  var M : Module . 
  vars T T' T1 T2 ST ST' PT BT CPT : Term .  
  vars TL VL : TermList .  
  var TS : TermSet .
  var C : Constant . 
  vars SUB SUB' SUB1 SUB2 SUBI : Substitution .  
  vars NextVar NextVar' N : Nat . 
  var VR : Variant . 
  var VS : VariantPairSet .
  var SR : StepResult . 
  var SRS : StepResultSet . 
  var NAR : NarrowingApplyResult . 
  var P : Parent . 
  var B : Bool .
  vars V1 V2 V3 : Variable .
  var RN : RuleName .

  op summarize : Term Substitution -> Substitution .
  op summarize : Term Substitution TermList -> Substitution .
  eq summarize(T, SUB) = summarize(T, SUB, VarsTerm(T)) .
  ceq summarize(T, V1 <- T1 ; SUB, VL) = summarize(T, SUB1, VL) 
   if not V1 in VL /\ SUB1 := SUB << (V1 <- T1) .
  eq summarize(T, SUB, VL) = SUB [owise] .

  op cleanRedundant : StepResult -> StepResult .
  ceq cleanRedundant({ST,V1 <- V2 ; SUB,RN | T}) 
    = cleanRedundant({ST << (V2 <- V1),SUB << (V2 <- V1),RN | T}) 
   if getType(V1) = getType(V2) .
  eq cleanRedundant(SR) = SR [owise] .

  var NAR : NarrowingApplyResult .
  var NRS : NarrowingResultSet .

--- Pre-condition: M is a Module, T is a Term, and N is a Nat.
--- Post-condition: Performs meta-narrowing to find the next possible states from a given term.
--- Developer: Kyungmin Bae, Kim Kyunwoo
--- Date: 2024/12/24
  op metaNarrowCollect : Module Term Nat -> StepResultSet .
  ceq metaNarrowCollect(M, T, N) 
    = {getTerm(NAR), getTermSubstitution(NAR), getLabel(NAR) | T} 
      || metaNarrowCollect(M, T, s N)
   if NAR := metaNarrowingApply(M, T, empty, '@, filter, N) .
  eq metaNarrowCollect(M, T, N) = empty .

  op getVariantTerms : VariantPairSet Term -> StepResultSet .
  eq getVariantTerms(empty, ST) = empty .
  eq getVariantTerms({T,SUB} # VS, ST) = { T, SUB, unlabeled | ST } || getVariantTerms(VS, ST) .

  op genVariants : Module StepResultSet -> StepResultSet .
  eq genVariants(M, empty) = empty .
  eq genVariants(M, {T,SUB,RN | ST} || SRS) = getVariantTerms(getVariantSet(M, T, '@), T) || genVariants(M, SRS) .
 
--- Pre-condition: ST is a Term and TL is a TermList.
--- Post-condition: Creates a list of conjunctions (as boolean terms) representing the PI-instantated states of the given state
--- Developer: Kyungmin Bae, Kim Kyunwoo
--- Date: 2024/12/24
  op conjAsBoolList : Term TermList -> TermList .
  eq conjAsBoolList(ST, (T,TL)) = '_|=_[ST, T], conjAsBoolList(ST, TL) .
  eq conjAsBoolList(ST, empty) = 'nil.GrBoolList .

--- Pre-condition: SRS is a StepResultSet.
--- Post-condition: Simplifies the substitutions within a StepResultSet by removing redundant assignments.
--- Developer: Kim Kyunwoo
--- Date: 2024/12/24
  op simplifySubstitutions : StepResultSet -> StepResultSet .
  eq simplifySubstitutions(empty) = empty .
  eq simplifySubstitutions({ST,SUB,RN | T} || SRS) = cleanRedundant({ST,summarize(T, SUB),RN | T}) || simplifySubstitutions(SRS) .

--- Pre-condition: M is a Module and SRS is a StepResultSet.
--- Post-condition: Filters out states from a StepResultSet based on their boolean condition and completeness information.
--- Developer: Kim Kyunwoo
--- Date: 2024/12/24  
  op filterStates : Module StepResultSet -> StepResultSet .
  eq filterStates(M, empty) = empty .
  ceq filterStates(M, {'`{`{`{_|_|_|_`}`}`}[ST, PT, BT, CPT],SUB,RN | T} || SRS) = filterStates(M, SRS) if BT == 'false.Bool or (not isMarkedIncomplete(M, CPT, true) and BT =/= 'true.Bool) .
  ceq filterStates(M, {'<<<_|_|_>>>[ST,BT,CPT],SUB,RN | T} || SRS) = filterStates(M, SRS) if BT == 'false.Bool or (not isMarkedIncomplete(M, CPT, true) and BT =/= 'true.Bool) .
  eq filterStates(M, {ST,SUB,RN | T} || SRS) = {ST,SUB,RN | T} || filterStates(M, SRS) [owise] .
endfm

mod PARTIAL-COMPLETENESS-FOLDING is
    pr STATE-SYNTAX .
    pr VARIANT-GENERATION .
    pr COMPLETENESS-DECLARATION .
    pr RULE-TERM-RENAMING .

    var M : Module .
    vars T T1 T2 : Term .
    vars ST1 PT1 CT1 ST2 PT2 CT2 CPT1 CPT2 : Term .
    var P : Term .
    vars VAR1 VAR2 : VariantPair .
    vars VARS1 VARS2 : VariantPairSet .
    vars BT1 BT2 : Term .
    var ET : Term .
    vars TL TL1 TL2 : TermList .
    var B : Bool .
    var IB : Bool .
    vars SUB1 SUB2 SUB' : Substitution .
    vars V1 V2 : Variable .

    op negate : Term -> Term .
    eq negate('true.Bool) = 'false.Bool .
    eq negate('false.Bool) = 'true.Bool .
    eq negate('_<=>_[ET, BT1]) = '_<=>_[ET, negate(BT1)] .
    eq negate('_and_[TL1]) = '_or_[negate(TL1)] .
    eq negate('_or_[TL1]) = '_and_[negate(TL1)] .

    op negate : TermList -> TermList .
    eq negate(empty) = empty .
    eq negate((T1, TL1)) = (negate(T1), negate(TL1)) .

    op filterTrue : VariantPairSet -> VariantPairSet .
    eq filterTrue({'true.Bool, SUB1} # VARS1) = {'true.Bool, SUB1} # filterTrue(VARS1) .
    eq filterTrue(VARS1) = empty [owise] .

--- Pre-condition: M is a Module and T is a Term.
--- Post-condition: Gets the variants that satisfy a given constraint term.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op getConstraintVariants : Module Term -> VariantPairSet .
    eq getConstraintVariants(M, T) = filterTrue(getVariantSet(M, renameRuleTerm(T), '%)) .

    op _>>_ : Substitution Substitution -> Substitution .
    eq none >> SUB2 = SUB2 .
    eq (V1 <- T1 ; SUB1) >> SUB2 = V1 <- $applySubstitution(T1, SUB2) ; (SUB1 >> SUB2) .

--- Pre-condition: M is a Module, SUB1 is a Substitution, and SUB2 is a Substitution.
--- Post-condition: Checks if all assignments in SUB1 are included in SUB2 (meaning SUB2 is more general or equal).
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op substitutionIncludes : Module Substitution Substitution -> Bool .
    eq substitutionIncludes(M, none, SUB2) = true .
    eq substitutionIncludes(M, (V1 <- T1) ; SUB1, (V1 <- T2) ; SUB2) = metaMatch(M, T1, T2, nil, 0) :: Substitution and substitutionIncludes(M, SUB1, SUB2) .
    eq substitutionIncludes(M, SUB1, SUB2) = false [owise] .

    op variantIncludes : Module VariantPair VariantPair Substitution -> Bool .
    eq variantIncludes(M, {T1,SUB1}, {T2,SUB2}, SUB') = substitutionIncludes(M, SUB1, SUB' >> SUB2) .

--- Pre-condition: M is a Module, VPS1 is a VariantPairSet, VPS2 is a VariantPairSet, and SUB is a Substitution.
--- Post-condition: Checks if all variants in the first set are included in the second set considering the given substitution.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op variantSetIncludes : Module VariantPairSet VariantPairSet Substitution -> Bool .
    eq variantSetIncludes(M, empty, VAR2, SUB') = true .
    eq variantSetIncludes(M, VAR1 # VARS1, VAR2, SUB') = variantIncludes(M, VAR1, VAR2, SUB') or variantSetIncludes(M, VARS1, VAR2, SUB') .

    op variantSetIncludes : Module VariantPairSet VariantPairSet Substitution -> Bool .
    eq variantSetIncludes(M, VARS1, empty, SUB') = true .
    eq variantSetIncludes(M, VARS1, VAR2 # VARS2, SUB') = variantSetIncludes(M, VARS1, VAR2, SUB') or variantSetIncludes(M, VARS1, VARS2, SUB') .

--- Pre-condition: M is a Module, CT1 is a Term, CT2 is a Term, CPT1 is a Term, CPT2 is a Term, and SUB is a Substitution.
--- Post-condition: Determines if the constraint represented by CT1 is stronger than or equal to the constraint represented by CT2, considering potential incompleteness.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op constraintIncludes : Module Term Term Term Term Substitution -> Bool .
    eq constraintIncludes(M, CT1, 'true.Bool, CPT1, CPT2, SUB') = getTerm(metaReduce(M, CT1)) == 'true.Bool .
    ceq constraintIncludes(M, CT1, CT2, CPT1, CPT2, SUB') = variantSetIncludes(M, getConstraintVariants(M, CT1), getConstraintVariants(M, CT2), SUB')
      if not isMarkedIncomplete(M, CPT1, true) /\ not isMarkedIncomplete(M, CPT2, true) .
    ceq constraintIncludes(M, CT1, CT2, CPT1, CPT2, SUB') = variantSetIncludes(M, getConstraintVariants(M, negate(CT1)), getConstraintVariants(M, negate(CT2)), SUB')
      if isMarkedIncomplete(M, CPT1, true) /\ isMarkedIncomplete(M, CPT2, true) /\ not isMarkedIncomplete(M, CPT1, false) /\ not isMarkedIncomplete(M, CPT2, false) .    
    eq constraintIncludes(M, CT1, CT2, CPT1, CPT2, SUB') = false [owise] .

--- Pre-condition: T1 is a Term, T2 is a Term, and M is a Module.
--- Post-condition: Determines if term T1 is greater than or equal to term T2, potentially using a user-defined subsumption relation for specific state representations.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
    op _>=_[_] : Term Term Module -> Bool .
    ceq '`{`{`{_|_|_|_`}`}`}[ST1, PT1, CT1, CPT1] >= '`{`{`{_|_|_|_`}`}`}[ST2, PT2, CT2, CPT2] [ M ] = (PT1 == PT2) and constraintIncludes(M, CT1, CT2, CPT1, CPT2, SUB')
      if SUB' := metaMatch(M, ST1, ST2, nil, 0) .
    eq '`{`{`{_|_|_|_`}`}`}[ST1, PT1, CT1, CPT1] >= '`{`{`{_|_|_|_`}`}`}[ST2, PT2, CT2, CPT2] [ M ] = false .
    eq T1 >= T2 [ M ] = metaMatch(M, T1, T2, nil, 0) :: Substitution .
endm

mod PATTERN-SIMPLIFICATION-RULE-VERIFICATION is
  pr META-LEVEL .

  var M : Module .
  var H : Header .  
  var IL : ImportList .  
  var SS : SortSet .  
  var SSDS : SubsortDeclSet .  
  var OPDS : OpDeclSet . 
  var MAS : MembAxSet .  
  var EQS : EquationSet .  
  var RL : Rule .
  var RLS : RuleSet .
  vars T T' T1 T2 T1' T2' : Term .
  var ATRS : AttrSet .
  var N : Nat .
  var L : Qid .

  sort PSValidationResult .

  var PSVR : PSValidationResult .

  op success : -> PSValidationResult [ctor] .
  op validationFail : NarrowingApplyResult Term Term Term Term -> PSValidationResult [ctor] .

  op _*_ : PSValidationResult PSValidationResult -> PSValidationResult [assoc] .
  eq success * success = success .
  eq success * validationFail(NAR, T1, T2, T1', T2') = validationFail(NAR, T1, T2, T1', T2') .
  eq validationFail(NAR, T1, T2, T1', T2') * PSVR = validationFail(NAR, T1, T2, T1', T2') .

  op getLhs : Rule -> Term .
  eq getLhs((rl T => T' [ATRS] .)) = T .

  op getRhs : Rule -> Term .
  eq getRhs((rl T => T' [ATRS] .)) = T' .

  op retrievePSRules : RuleSet -> RuleSet .
  eq retrievePSRules((rl T => T' [metadata("ps") ATRS] .) RLS) = (rl T => T' [metadata("ps") ATRS] .) retrievePSRules(RLS) .
  eq retrievePSRules(RLS) = none [owise] .

  op retrievePSRules : Module -> RuleSet .
  eq retrievePSRules(M) = retrievePSRules(getRls(M)) .

  op excludePSRules : RuleSet -> RuleSet .
  eq excludePSRules((rl T => T' [metadata("ps") ATRS] .) RLS) = excludePSRules(RLS) .
  eq excludePSRules(RLS) = RLS [owise] .

  op excludePSRules : Module -> Module .
  eq excludePSRules(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm) = mod H is IL sorts SS . SSDS OPDS MAS EQS excludePSRules(RLS) endm .

  op isolatePSRules : Module -> Module .
  eq isolatePSRules(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm) = mod H is IL sorts SS . SSDS OPDS MAS EQS retrievePSRules(RLS) endm .

  op isolatePSRule : Module Rule -> Module .
  eq isolatePSRule(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm, RL) = mod H is IL sorts SS . SSDS OPDS MAS EQS RL endm .

  sort NarrowingResultSet .
  op nil : -> NarrowingResultSet [ctor] .
  subsort NarrowingApplyResult < NarrowingResultSet .
  op _;_ : NarrowingResultSet NarrowingResultSet -> NarrowingResultSet [assoc comm ctor id: nil] .

  op metaNarrowCollect : Module Term Nat -> NarrowingResultSet .
  ceq metaNarrowCollect(M, T, N) = NAR ; metaNarrowCollect(M, T, s N)
    if NAR := metaNarrowingApply(M, T, empty, '@, filter, N) .
  eq metaNarrowCollect(M, T, N) = nil [owise] .

  op applyNarrowingSubstitutionToPSRuleLhs : Module NarrowingApplyResult Rule -> Term .
  eq applyNarrowingSubstitutionToPSRuleLhs(M, NAR, (rl T => T' [metadata("ps") ATRS] .)) = $applySubstitution(T, getTermSubstitution(NAR)) .

  op applyNarrowingSubstitutionToPSRuleRhs : Module NarrowingApplyResult Rule -> Term .
  eq applyNarrowingSubstitutionToPSRuleRhs(M, NAR, (rl T => T' [metadata("ps") ATRS] .)) = $applySubstitution(T', getTermSubstitution(NAR)) .

  op applyPSRuleToNarrowingResultTerm : Module NarrowingApplyResult Rule -> Term .
  eq applyPSRuleToNarrowingResultTerm(M, NAR, RL) = getTerm(metaRewrite(isolatePSRule(M, RL), getTerm(NAR), 2)) .

  op rewritePSRuleRhs : Module Term Qid -> Term .
  eq rewritePSRuleRhs(M, T, L) = getTerm(metaApply(M, T, L, none, 0)) .

  op testTermEquality : Module Term Term -> Bool .
  ceq testTermEquality(M, T, T') = getTerm(metaReduce(M, '_==_[T, T'])) == 'true.Bool if B:Bool := getTerm(metaReduce(M, '_==_[T, T'])) == 'true.Bool .

  op testPSApplication : Module NarrowingApplyResult Term Term Term Term -> PSValidationResult .
  eq testPSApplication(M, NAR, T1, T2, T1', T2') = if metaSearch(isolatePSRules(M), T1', T2', nil, '+, 1, 0) :: ResultTriple 
                                    then success 
                                    else validationFail(NAR, T1, T2, T1', T2') fi .

  op validatePSNarrowingResult : Module NarrowingApplyResult Rule -> PSValidationResult .
  eq validatePSNarrowingResult(M, NAR, RL)
    = testPSApplication(M, NAR,
        applyNarrowingSubstitutionToPSRuleLhs(M, NAR, RL),
        applyNarrowingSubstitutionToPSRuleRhs(M, NAR, RL),            
        getTerm(NAR), 
        rewritePSRuleRhs(M, applyNarrowingSubstitutionToPSRuleRhs(M, NAR, RL), getLabel(NAR))) .

  op validatePSNarrowingResults : Module NarrowingResultSet Rule -> PSValidationResult .
  eq validatePSNarrowingResults(M, nil, RL) = success .
  eq validatePSNarrowingResults(M, NAR ; NRS, RL) = validatePSNarrowingResult(M, NAR, RL) * validatePSNarrowingResults(M, NRS, RL) .

  op validatePSRule : Module Rule -> PSValidationResult .
  eq validatePSRule(M, (rl T => T' [metadata("ps") ATRS] .)) = validatePSNarrowingResults(M, metaNarrowCollect(excludePSRules(M), T, 0), (rl T => T' [metadata("ps") ATRS] .)) .

  op validatePSRules : Module RuleSet -> PSValidationResult .
  eq validatePSRules(M, none) = success .
  eq validatePSRules(M, RL RLS) = validatePSRule(M, RL) * validatePSRules(M, RLS) .

  op validatePSRules : Module -> PSValidationResult .
  eq validatePSRules(M) = validatePSRules(M, retrievePSRules(M)) .
endm

mod VERIFY-USER-DEFINED-RULES is
  pr META-LEVEL .

  var M : Module .

--- Pre-condition: M is a Module.
--- Post-condition: Placeholder for verifying user-defined rules (currently always returns true).
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
  op verifyUserDefinedRules : Module -> Bool .
  eq verifyUserDefinedRules(M) = true .
endm

mod ENABLED-AUTO-GENERATION is
  pr META-LEVEL .
  pr SATISFACTION .
  pr STRING .

  var H : Header .  
  var IL : ImportList .  
  var ME : ModuleExpression .
  var SS : SortSet .  
  var SSDS : SubsortDeclSet .  
  vars OPDS OPDS' : OpDeclSet . 
  var MAS : MembAxSet .  
  vars EQS EQS' : EquationSet .  
  var RL : Rule .
  var RLS : RuleSet .
  var STDS : StratDeclSet .
  var STDFS : StratDefSet .
  var ATRS : AttrSet .
  var M : Module . 

  vars T LT RT : Term .
  var TL : TermList .

  op enabledProp : -> Term .
  eq enabledProp = 'enabled?.Prop .

  op isStateRule : Module Rule -> Bool .
  eq isStateRule(M, (rl LT => RT [ATRS] .)) = sortLeq(M, leastSort(M, LT), 'State) .

  op getStateRules : Module RuleSet -> RuleSet .
  eq getStateRules(M, none) = none .
  eq getStateRules(M, RL RLS) = if isStateRule(M, RL) then RL else none fi getStateRules(M, RLS) .

  op getRuleLhss : RuleSet -> TermList .
  eq getRuleLhss(none) = empty .
  eq getRuleLhss((rl LT => RT [ATRS] .) RLS) = LT, getRuleLhss(RLS) .

  op genEnabledEq : Term -> Equation .
  eq genEnabledEq(T) = (eq '_|=_[T, enabledProp] = 'true.Bool [variant] .) .

  op genEnabledEqs : TermList -> EquationSet .
  eq genEnabledEqs(empty) = none .
  eq genEnabledEqs((T, TL)) = genEnabledEq(T) genEnabledEqs(TL) .

  op genEnabledEqs : Module -> EquationSet .
  eq genEnabledEqs(M) = genEnabledEqs(getRuleLhss(getStateRules(M, getRls(M)))) .

  op enabledDecl : -> OpDecl .
  eq enabledDecl = (op 'enabled? : nil -> 'Prop [metadata("incomplete(false)")] .) .

  op addEqs : Module EquationSet -> Module .
  eq addEqs(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm, EQS') = mod H is IL sorts SS . SSDS OPDS MAS (EQS EQS') RLS endm .
  eq addEqs(smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm, EQS') = smod H is IL sorts SS . SSDS OPDS MAS (EQS EQS') RLS STDS STDFS endsm .

  op addDecls : Module OpDeclSet -> Module .
  eq addDecls(mod H is IL sorts SS . SSDS OPDS MAS EQS RLS endm, OPDS') = mod H is IL sorts SS . SSDS (OPDS OPDS') MAS EQS RLS endm .
  eq addDecls(smod H is IL sorts SS . SSDS OPDS MAS EQS RLS STDS STDFS endsm, OPDS') = smod H is IL sorts SS . SSDS (OPDS OPDS') MAS EQS RLS STDS STDFS endsm .

  op addEnabledEqs : Module -> Module .
  eq addEnabledEqs(M) = addEqs(M, genEnabledEqs(M)) .

  op addEnabledDecl : Module -> Module .
  eq addEnabledDecl(M) = addDecls(M, enabledDecl) .

  op addEnabled : Module -> Module .
  eq addEnabled(M) = addEnabledEqs(addEnabledDecl(M)) .
endm

mod META-SYMBOLIC-CONNECTOR is
  pr META-LMC-THEORY .
  pr BOUNDED-FOLDING-MODEL-CHECKER .
  pr COMPLETENESS-DECLARATION .
  pr META-NARROWING-INTERFACE .
  pr DECL-META-PRETTY-PRINT 
   * (op addOps to addOpsSE, op addEqs to addEqsSE, op addSorts to addSortsSE) .
  pr RULE-EXPANSION .
  pr PARTIAL-COMPLETENESS-FOLDING .
  pr VERIFY-USER-DEFINED-RULES .

  var M : Module .  
  vars T T' T1 T2 ST ST' PT CT : Term . 
  var RN : RuleName . 
  var RS : RuleSet . 
  var TL : TermList .  
  var V : Variable . 
  var TP : Type . 
  vars SUB SUB' SUB'' : Substitution .  
  var B : Bool . 
  var N : Nat . 
  var D : Bound .
  var RT : ResultTriple .
  var RTS : ResultTripleSet . 

--- meta prop and state
  ceq mid(ST) |= prop(PT) 
   = getTerm(metaReduce((##m##), '_|=_[ST, PT])) == 'true.Bool if TT:Term := getTerm(metaReduce((##m##), '_|=_[ST, PT])) .

--- state folding
  eq init(ST) >= init(ST) = true .
  eq mid(ST) >= mid(ST') = ST >= ST' [##m##] .
  eq S1:State >= S2:State = false [owise] .

--- renaming folding
  eq init(ST) ~= init(ST) = true .
  eq mid(ST) ~= mid(ST')
   = mid(ST) >= mid(ST') and-then mid(ST') >= mid(ST) .
  eq S1:State ~= S2:State = false [owise] .

--- Pre-condition: ST is a Term.
--- Post-condition: Gets candidate next states by performing meta-narrowing on the expanded rules.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
  op nextCandidates : Term -> StepResultSet .
  eq nextCandidates(ST) = metaNarrowCollect(expandRules(trMod(##m##), ##f##), ST, 0) |> ST .

--- Pre-condition: ST is a Term.
--- Post-condition: Gets candidate initial states by generating variants of the initial state.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
  op initCandidates : Term -> StepResultSet .
  eq initCandidates(ST) = genVariants(trMod(##m##), trStateSet(ST)) .

--- Pre-condition: SRS is a StepResultSet.
--- Post-condition: Transforms a StepResultSet for initial states into a StepResultSet for mid-states, effectively stepping from the initial state.
--- Author: Kim Kyunwoo
--- Date: 2024/12/24
  op initStep : StepResultSet -> StepResultSet .
  eq initStep(empty) = empty .
  eq initStep({T,SUB,RN | ST} || SRS:StepResultSet) = next(T) || initStep(SRS:StepResultSet) .

  eq next(ST) 
    = simplifySubstitutions(filterStates(trMod(##m##), nextCandidates(ST))) .

  eq initVariant(ST) 
    = initStep(simplifySubstitutions(filterStates(trMod(##m##), initCandidates(ST)))) .

  op wrapInitState : Term -> Term .
  eq wrapInitState('<<<_|_>>>[TL]) = '<<<_|_>>>[TL] .
  eq wrapInitState(T) = '<<<_|_>>>[T, 'true.Bool] [owise] .

  op trStateSet : Term -> StepResultSet .
  eq trStateSet('_\/_[empty]) = empty .
  eq trStateSet('_\/_[T,TL]) = {wrapInitState(T),none,unlabeled | wrapInitState(T)} || trStateSet('_\/_[TL]) .
  eq trStateSet(ST) = {wrapInitState(ST),none,unlabeled | wrapInitState(ST)} [owise] .

  op verificationFailure : -> BoundedModelCheckReport [ctor] .

--- Pre-condition: ST is a Term representing the initial state, PT is a Term representing the property, B is a Bool indicating folding, and D is a Bound.
--- Post-condition: Performs logical model checking on a given state and property, returning a BoundedModelCheckReport.
--- Author: Kyungmin Bae
--- Date: 2024/12/24
  op lmc-check : Term Term Bool Bound ~> BoundedModelCheckReport .
 ceq lmc-check(ST, PT, B, D) 
   = if verifyUserDefinedRules(##m##) then symbolicModelCheck(init(ST), O O tilde((##m##),PT), B, D) 
     else verificationFailure fi
  if sortLeq((##m##), leastSort((##m##),ST), 'StateSet)
  /\ sortLeq((##m##), leastSort((##m##),PT), 'Formula) .

--- meta formula
  op tilde : Module Term -> Formula .
 ceq tilde(M, PT)             = prop(PT) if sortLeq(M,leastSort(M,PT),'Prop) .
  eq tilde(M, 'True.Formula)  = True .
  eq tilde(M, 'False.Formula) = False .
  eq tilde(M, '~_[T])         = ~ tilde(M, T) .
  eq tilde(M, '_/\_[T, T'])   = tilde(M, T) /\ tilde(M, T') .
  eq tilde(M, '_\/_[T, T'])   = tilde(M, T) \/ tilde(M, T') .
  eq tilde(M, 'O_[T])         = O tilde(M, T) .
  eq tilde(M, '_U_[T, T'])    = tilde(M, T) U tilde(M, T') .
  eq tilde(M, '_R_[T, T'])    = tilde(M, T) R tilde(M, T') .

--- pretty print (for debugging)
  eq prettyPrint(init(ST)) = eMetaPrettyPrint((##m##), ST) .
  eq prettyPrint(mid(ST))  = eMetaPrettyPrint((##m##), ST) .

  eq prettyPrint(-[SUB]/ RN -) 
    = ---eMetaPrettyPrint((##m##), RS) '/ 
      prettyPrintSub(SUB) .

  op prettyPrintSub : Substitution -> QidList .
  eq prettyPrintSub(none) = 'none .
  eq prettyPrintSub(V <- T) = V '<- eMetaPrettyPrint((##m##),T) .
  eq prettyPrintSub(V <- T ; A:Assignment ; SUB) 
   = V '<- eMetaPrettyPrint((##m##),T) '; prettyPrintSub(A:Assignment ; SUB) .
endm

*****************************************
***       Extending Full Maude        ***
*****************************************

--- REDEFINED
fmod FM-BANNER is
  pr STRING .
  op banner : -> String .
  eq banner = "Logical Model Checker" .
endfm


fmod LMC-COMMANDS is
  inc FM-COMMANDS .
  op lmc_|=_. : @Bubble@ @Bubble@ -> @Command@ [ctor] .
  op lfmc_|=_. : @Bubble@ @Bubble@ -> @Command@ [ctor] .
endfm


--- REDEFINED
fmod FULL-MAUDE-SIGN is
  including FM-VIEWS .
  inc LMC-COMMANDS .

  sort @Input@ .
  subsorts @Command@ @Module@ @View@ < @Input@ .
endfm


fmod META-PROP-SET is
  pr META-LEVEL .

  var M : Module . 
  vars T T' : Term .

  op props : Module Term -> TermList .
  eq props(M, T) = #props(M, getTerm(metaReduce(M, T))) .

  op #props : Module Term -> TermList .   --- Formula -> PropList .
 ceq #props(M, T)            = T if sortLeq(M, leastSort(M, T), 'Prop) .
  eq #props(M, '~_[T])       = #props(M, T) .
  eq #props(M, '_/\_[T, T']) = #props(M, T), #props(M, T') .
  eq #props(M, '_\/_[T, T']) = #props(M, T), #props(M, T') .
  eq #props(M, 'O_[T])       = #props(M, T) .
  eq #props(M, '_U_[T, T'])  = #props(M, T), #props(M, T') .
  eq #props(M, '_R_[T, T'])  = #props(M, T), #props(M, T') .
  eq #props(M, T)            = empty [owise] .
endfm


mod META-LMC-COUNTEREXAMPLE-TRANSFORMER is
  pr META-LMC-THEORY .
  pr BOUNDED-FOLDING-MODEL-CHECKER .

  vars Q F : Qid . 
  var M : Module .  
  var V : Variable . 
  var C : Constant .
  var CD : Condition . 
  vars T T' ST PT : Term . 
  var TL : TermList . 
  var TR : Transition . 
  var TRL TRL' : TransitionList . 
  var RS : RuleSet . 
  var RN : RuleName .  
  var AtS : AttrSet . 
  var SUB : Substitution . 
  var ME : MetaEdge .
  var D : Bound . 
  vars B BC BR : Bool . 
  var MR : ModelCheckResult .

--- Pre-condition: MR is a ModelCheckResult.
--- Post-condition: Transforms a ModelCheckResult into a Term representing the counterexample trace.
--- Author: Kyungmin Bae
--- Date: 2024/12/24
  op transRes : ModelCheckResult -> Term .
  eq transRes(B) = upTerm(B:Bool) .
  eq transRes(prefix TRL loop TRL')
   = 'prefix_loop_[wrapTL('__,'nil.TransitionList,transTRs(TRL)), 
                           wrapTL('__,'nil.TransitionList,transTRs(TRL'))] .

--- Pre-condition: TRL is a TransitionList.
--- Post-condition: Transforms a list of transitions into a TermList suitable for representing counterexamples.
--- Author: Kyungmin Bae
--- Date: 2024/12/24
  op transTRs : TransitionList -> TermList .
  eq transTRs(TR TRL) = transTR(TR), transTRs(TRL) .
  eq transTRs(nil)    = empty .

--- Pre-condition: TR is a Transition.
--- Post-condition: Transforms a Transition into a TermList representing a step in the counterexample.
--- Author: Kyungmin Bae
--- Date: 2024/12/24
  op transTR : Transition -> TermList .
  eq transTR({mid(ST), -[SUB]/ RN -})  
   = '`{_`,_`,_`}[ST, wrapTL('_;_,'none.CESubstitution,transSUB(SUB)), upRuleName(RN)] .
  eq transTR({mid(ST), deadlock})  
   = '`{_`,_`,_`}[ST, 'none.CESubstitution, upRuleName(deadlock)] .
  eq transTR({init(ST), -[SUB]/ RN -}) = empty  .

--- Pre-condition: SUB is a Substitution.
--- Post-condition: Transforms a Substitution into a TermList representing assignments in the counterexample.
--- Author: Kyungmin Bae
--- Date: 2024/12/24  
  op transSUB : Substitution -> TermList .
  eq transSUB(none) = empty .
  eq transSUB(V <- T ; SUB) 
   = '_<-_[qid("'" + string(getName(V)) + ".Qid"), T], transSUB(SUB) .

  op wrapTL : Qid Constant TermList -> Term .
  eq wrapTL(F, C, T) = T .
  eq wrapTL(F, C, (T,T',TL)) = F[T,T',TL] .
  eq wrapTL(F, C, empty) = C .

  op upRuleName : RuleName -> Constant .
  eq upRuleName(Q) = qid("'" + string(Q) + ".Qid") .
  eq upRuleName(RN) = upTerm(RN) [owise] .

  op getRuleName : RuleSet -> RuleName .
  eq getRuleName((rl T => T' [label(Q) AtS] .) RS) = Q .
  eq getRuleName((crl T => T' if CD [label(Q) AtS] .) RS) = Q .
  eq getRuleName(RS) = unlabeled [owise] .
endm

mod LMC-COMMAND-PROCESSING is
  pr FM-COMMAND-PROCESSING .
  pr META-PROP-SET .
  pr ENABLED-AUTO-GENERATION .

  vars T T1 T2 T3 T4 T5 T6 : Term .  
  var TL TL1 : TermList .
  vars DB DB1 : Database .
  vars M U M1 M2 : Module .
  vars ME ME1 : ModuleExpression .
  vars  B BC : Bool .
  var D : Bound .
  var CD : Condition .
  var  QIL : QidList .
  vars VS VDS : VariableSet .
  vars QI QI' F V O : Qid .  
  var TY : Type .
  var  TDM : Tuple{Database,ModuleExpression} .
  var  TMVB : [Tuple{Term,Module,Bool,VariableSet,Bound,Database}] .
  var RP : ResultPair . 
  var  RP? : [ResultPair] .

--- Pre-condition: QI is a Qid, ME is a ModuleExpression, and DB is a Database.
--- Post-condition: Processes a logical model checking command.
--- Author: Kyungmin Bae
--- Date: 2024/12/24
  op procLMCComd : Term ModuleExpression Database -> Tuple{Database,QidList} .

  eq procLMCComd(QI, ME, DB)
   = if compiledModule(ME, DB)
     then procLMC(QI, empty, nil, unbounded, 
                  getFlatModule(ME,DB), getVars(ME,DB), DB)
     else procLMC(QI, empty, nil, unbounded,
                  getFlatModule(modExp(evalModExp(ME,DB)),
                                database(evalModExp(ME,DB))),
                  getVars(modExp(evalModExp(ME,DB)),
                          database(evalModExp(ME,DB))),
                  database(evalModExp(ME,DB)))
     fi .

 --- there exist arguments
 ceq procLMCComd(F[TL], ME, DB)
   = if compiledModule(ME, DB)
     then procLMCComd(F, TL, getFlatModule(ME,DB), B, unbounded, 
                      getVars(ME,DB), DB, empty)
     else procLMCComd(F, TL, 
                      getFlatModule(modExp(evalModExp(ME,DB)),
                                    database(evalModExp(ME,DB))), 
                      B, unbounded,
                      getVars(modExp(evalModExp(ME,DB)),
                              database(evalModExp(ME,DB))),
                      database(evalModExp(ME,DB)), empty)
     fi 
  if B  := included('META-MODULE, getImports(getTopModule(ME,DB)), DB) .

-------------------------------------
--- parse arguments
---

--- Pre-condition: QI is a Qid.
--- Post-condition: Returns the expected type of the condition argument for a given LMC command.
--- Author: Kyungmin Bae
--- Date: 2024/12/24
  op lmcCmdCond : Qid -> Type? .
  eq lmcCmdCond('lmc_|=_.)  = 'Formula .
  eq lmcCmdCond('lfmc_|=_.) = 'Formula .
  eq lmcCmdCond(QI) = anyType [owise] . --- no condition

--- Pre-condition: F is a Qid, TL is a TermList, M is a Module, B is a Bool, D is a Bound, VDS is a VariableSet, DB is a Database, and TL1 is a TermList.
--- Post-condition: Processes a logical model checking command, handling argument parsing and execution.
--- Author: Kyungmin Bae
--- Date: 2024/12/24
  op procLMCComd : Qid TermList Module Bool Bound VariableSet Database TermList 
                -> Tuple{Database,QidList} .

  eq procLMCComd(F, TL, unitError(QIL), B, D, VDS, DB, TL1) = << DB ; QIL >> .

  --- the first argument
  ceq procLMCComd(F, (T,TL), M, B, D, VDS, DB, empty)  
    = if getModule(TMVB) :: Module and-then getTerm(TMVB) :: Term
      then procLMCComd(F, TL, getModule(TMVB), B, getBound(TMVB),
                        getVars(TMVB), getDatabase(TMVB), getTerm(TMVB))
      else << DB ; getMsg(getTerm(metaReduce(getModule(TMVB), getTerm(TMVB)))) >>
      fi
    if TMVB := solveBubblesRew(T, M, B, unbounded, VDS, DB) . --- "[1] in MOD :"

  --- intermediate arguments
  ceq procLMCComd(F, (T1,T2,TL), M, B, D, VDS, DB, TL1) 
    = if T?:[Term] :: Term
      then procLMCComd(F, (T2,TL), M, B, D, VDS, DB, (TL1,T?:[Term]))
      else << DB ; getMsg(T?:[Term]) >> fi
    if T?:[Term] := solveBubbles(T1,M,B,VDS,DB) .

  --- the last argument (no condition)
  ceq procLMCComd(F, 'bubble[QI], M, B, D, VDS, DB, TL1) 
    = if T?:[Term] :: Term
      then procLMC(F, (TL1,T?:[Term]), nil, D, M, VDS,DB)
      else << DB ; getMsg(T?:[Term]) >> fi
    if T?:[Term] := solveBubbles('bubble[QI],M,B,VDS,DB) .

  --- the last argument (may have condition)
  ceq procLMCComd(F, 'bubble['__[TL]], M, B, D, VDS, DB, TL1)
  = if T?:[Term] :: Term
      then procLMC(F, (TL1,T?:[Term]), nil, D, M, VDS,DB)
      else << DB ; getMsg(T?:[Term]) >> fi
  if T?:[Term] := solveBubbles('bubble['__[TL]], M, B, VDS, DB) .

-------------------------------------
--- execute commands
---

--- Pre-condition: F is a Qid, TL is a TermList, CD is a Condition, D is a Bound, M is a Module, VDS is a VariableSet, and DB is a Database.
--- Post-condition: Executes the logical model checking command.
--- Author: Kyungmin Bae
--- Date: 2024/12/24
  op procLMC : Qid TermList Condition Bound Module VariableSet Database -> Tuple{Database,QidList} .

  eq procLMC('lfmc_|=_., (T1,T2), CD, D, M, VDS, DB)
   = procLMCExec(T1, T2, CD, true, D, M, DB) .
  eq procLMC('lmc_|=_., (T1,T2), CD, D, M, VDS, DB)
   = procLMCExec(T1, T2, CD, false, D, M, DB) .

--- Pre-condition: T1 is a Term representing the initial state, T2 is a Term representing the property, CD is a Condition, B is a Bool indicating folding, D is a Bound, M is a Module, and DB is a Database.
--- Post-condition: Executes the core logical model checking process.
--- Author: Kyungmin Bae
--- Date: 2024/12/24
  op procLMCExec : Term Term Condition Bool Bound Module Database -> Tuple{Database,QidList} .
  ceq procLMCExec(T1, T2, CD, B, D, M, DB)
   = if RP? :: ResultPair
     then << DB ; printLMCInfo(M,B,T1,T2,CD) printLMCOutput(M,getTerm(RP?)) >>
     else << DB ; getMsg(getTerm(RP?)) >>
     fi
   if EL:TermList := enabledProp, props(M,T2) /\
      M':Module := addEnabled(M) /\
      U := addEqs( 
	    (eq '##m##.Module = up(M) [none] .
	     eq '##f##.TermList = upTerm(props(M,T2)) [none] .),
	    upModule('META-SYMBOLIC-CONNECTOR, false)) /\
      T3  := up(getTerm(metaReduce(M,T1))) /\
      T4 := up(getTerm(metaReduce(M,T2))) /\
      RP? := metaReduce(U, 'lmc-check[T3,T4,upTerm(B),upTerm(D)]) .

--- Pre-condition: M is a Module, B is a Bool indicating folding, T1 is a Term representing the initial state, T2 is a Term representing the property, and CD is a Condition.
--- Post-condition: Generates a QidList containing information about the model checking process being initiated.
--- Author: Kyungmin Bae
--- Date: 2024/12/24
  op printLMCInfo : Module Bool Term Term Condition -> QidList .
  eq printLMCInfo(M, B, T1, T2, CD)
   = '\b 'logical (if B then 'folding else nil fi) 'model 'check 'in
     '\o eMetaPrettyPrint(getName(M)) '\b ': '\o '\n '\s '\s
     eMetaPrettyPrint(M,T1) '\b '\s '|= '\s '\o eMetaPrettyPrint(M,T2) 
     (if CD == nil then nil
      else '\n '\b 'under 'the 'condition ': '\o '\n '\s '\s
      eMetaPrettyPrint(M,CD) fi) '\n .

--- Pre-condition: M is a Module and T is a Term representing the model checking result.
--- Post-condition: Generates a QidList containing the output of the model checker, including results and potential counterexamples.
--- Author: Kyungmin Bae
--- Date: 2024/12/24
  op printLMCOutput : Module Term -> QidList .
  eq printLMCOutput(M, 'result:_real:_bound:_complete:_[T1,T2,T3,T4])
   = '\b 'result: '\o '\n '\s '\s
     (if T1 == 'true.Bool then 
        if T4 == 'true.Bool then
          'true '\s '`( 'complete 'with 'depth eMetaPrettyPrint(M,T3) '`)
        else 
          'no 'counterexample 'found 'within 'bound eMetaPrettyPrint(M,T3)
        fi
      else 
        if T2 == 'true.Bool then nil else 'possibly 'spurious fi
        'counterexample 'found 'at 'depth eMetaPrettyPrint(M,T3) '\n '\s '\s
        printLMCCE(M, T1)
      fi) '\n .
    eq printLMCOutput(M, 'verificationFailure.BoundedModelCheckReport) = 'Verification 'faliure .

  eq printLMCOutput(M, T)
   = '\b 'error: '\o '\n '\s '\s
     'model 'checker 'internal 'error '\n [owise] .

--- Pre-condition: M is a Module and T is a Term representing the counterexample.
--- Post-condition: Generates a QidList containing the pretty-printed counterexample.
--- Author: Kyungmin Bae
--- Date: 2024/12/24
  op printLMCCE : Module Term -> QidList .
 ceq printLMCCE(M, T)
   = eMetaPrettyPrint(M, downTerm(getTerm(RP)))
  if RP := metaReduce(upModule('META-LMC-COUNTEREXAMPLE-TRANSFORMER,false),
                      'transRes[T]) .
  eq printLMCCE(M, T)
   = 'invalid 'counterexample 'term .
endm


mod LMC-DATABASE-HANDLING is
  inc FM-DATABASE-HANDLING .
  pr LMC-COMMAND-PROCESSING .

  var Atts : AttributeSet . 
  var X@DatabaseClass : DatabaseClass . 
  var F : Qid . 
  var O : Oid .  
  var ME : ModuleExpression . 
  var DB : Database .
  var TL : TermList . 
  var T T' : Term . 
  var QIL : QidList .

 crl [LMC] :
    < O : X@DatabaseClass | 
       db : DB, input : (F[TL]), output : QIL, default : ME, Atts >
   => 
    < O : X@DatabaseClass | 
       db : getDatabase(procLMCComd(F[TL], ME, DB)),
       input : nilTermList, 
       output : getQidList(procLMCComd(F[TL], ME, DB)), 
       default : ME, Atts > 
   if (F == 'lmc_|=_.) or-else (F == 'lfmc_|=_.) .
endm


mod LMC-FULL-MAUDE is
  pr FULL-MAUDE .
  pr LMC-DATABASE-HANDLING .
endm

set trace off .
set break off .
set profile off .

loop init .